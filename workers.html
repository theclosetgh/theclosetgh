/**
 * THE CLOSET API (Cloudflare Worker + D1)
 * Routes:
 *  GET    /api/health
 *  POST   /api/login                 { password } -> { ok, token }
 *  GET    /api/products              -> { ok, products[] }
 *  POST   /api/products              (auth) create
 *  PUT    /api/products/:id          (auth) update
 *  DELETE /api/products/:id          (auth) delete
 *
 * Bindings required:
 *  - D1 Database binding name: DB
 *  - Secret: ADMIN_PASSWORD
 *  - Secret: SESSION_SECRET
 */

export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    // ---- CORS (tighten later to only your domains) ----
    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization",
    };

    if (request.method === "OPTIONS") {
      return new Response("", { headers: corsHeaders });
    }

    const json = (obj, status = 200) =>
      new Response(JSON.stringify(obj), {
        status,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      });

    // ---- Ensure required bindings exist ----
    const requireEnv = () => {
      if (!env || !env.DB) throw new Error("Missing D1 binding: DB");
      if (!env.ADMIN_PASSWORD) throw new Error("Missing secret: ADMIN_PASSWORD");
      if (!env.SESSION_SECRET) throw new Error("Missing secret: SESSION_SECRET");
    };

    // ---- HMAC token helpers (Authorization: Bearer <token>) ----
    async function hmacSign(payload) {
      const enc = new TextEncoder();
      const secret = String(env.SESSION_SECRET || "");
      const key = await crypto.subtle.importKey(
        "raw",
        enc.encode(secret),
        { name: "HMAC", hash: "SHA-256" },
        false,
        ["sign"]
      );
      const sigBuf = await crypto.subtle.sign("HMAC", key, enc.encode(payload));
      const sigBytes = new Uint8Array(sigBuf);

      // base64url (no padding)
      const b64 = btoa(String.fromCharCode(...sigBytes))
        .replaceAll("+", "-")
        .replaceAll("/", "_")
        .replaceAll("=", "");
      return b64;
    }

    async function makeToken(role, expMs) {
      const payload = `${role}|${expMs}`;
      const sig = await hmacSign(payload);
      return `${payload}.${sig}`;
    }

    async function verifyToken(token) {
      if (!token) return false;

      const parts = token.split(".");
      if (parts.length !== 2) return false;

      const payload = parts[0];
      const sig = parts[1];
      const expected = await hmacSign(payload);

      if (sig !== expected) return false;

      const [role, expStr] = payload.split("|");
      const exp = Number(expStr);

      if (role !== "admin") return false;
      if (!Number.isFinite(exp) || Date.now() > exp) return false;

      return true;
    }

    function getBearerToken(req) {
      const h = req.headers.get("Authorization") || "";
      if (!h.toLowerCase().startsWith("bearer ")) return null;
      return h.slice(7).trim();
    }

    async function requireAuth(req) {
      const token = getBearerToken(req);
      return await verifyToken(token);
    }

    // ---- Routes ----

    // Health
    if (url.pathname === "/api/health") {
      return json({ ok: true });
    }

    // Login (password only) -> returns token
    if (url.pathname === "/api/login" && request.method === "POST") {
      try {
        requireEnv();
        const body = await request.json().catch(() => ({}));
        const pass = String(body.password || "");

        if (pass !== String(env.ADMIN_PASSWORD || "")) {
          return json({ ok: false, error: "Invalid password" }, 401);
        }

        const exp = Date.now() + 7 * 24 * 60 * 60 * 1000; // 7 days
        const token = await makeToken("admin", exp);

        return json({ ok: true, token });
      } catch (e) {
        return json({ ok: false, error: e?.message || "Server error" }, 500);
      }
    }

    // Public list
    if (url.pathname === "/api/products" && request.method === "GET") {
      try {
        requireEnv();

        const r = await env.DB.prepare(
          "SELECT * FROM products ORDER BY createdAt DESC"
        ).all();

        const results = r?.results || [];

        const products = results.map((p) => ({
          id: p.id,
          name: p.name,
          price: Number(p.price),
          sizes: JSON.parse(p.sizes || "[]"),
          imageUrl: p.imageUrl,
          discountEnabled: !!p.discountEnabled,
          discountPercent: Number(p.discountPercent || 0),
          outOfStock: !!p.outOfStock,
          createdAt: p.createdAt,
        }));

        return json({ ok: true, products });
      } catch (e) {
        return json({ ok: false, error: "DB error: " + (e?.message || "unknown") }, 500);
      }
    }

    // Admin create
    if (url.pathname === "/api/products" && request.method === "POST") {
      try {
        requireEnv();
        if (!(await requireAuth(request))) {
          return json({ ok: false, error: "Unauthorized" }, 401);
        }

        const body = await request.json().catch(() => ({}));
        const id = crypto.randomUUID();

        const name = String(body.name || "").trim();
        const price = Math.round(Number(body.price || 0));
        const sizes = Array.isArray(body.sizes) ? body.sizes : [];
        const imageUrl = String(body.imageUrl || "").trim();

        const discountEnabled = body.discountEnabled ? 1 : 0;
        const discountPercent = Math.round(Number(body.discountPercent || 0));
        const outOfStock = body.outOfStock ? 1 : 0;
        const createdAt = new Date().toISOString();

        if (!name || !imageUrl || !Number.isFinite(price) || price <= 0 || sizes.length === 0) {
          return json({ ok: false, error: "Invalid payload" }, 400);
        }

        await env.DB.prepare(
          `INSERT INTO products
           (id,name,price,sizes,imageUrl,discountEnabled,discountPercent,outOfStock,createdAt)
           VALUES (?,?,?,?,?,?,?,?,?)`
        )
          .bind(
            id,
            name,
            price,
            JSON.stringify(sizes),
            imageUrl,
            discountEnabled,
            discountPercent,
            outOfStock,
            createdAt
          )
          .run();

        return json({ ok: true, id });
      } catch (e) {
        return json({ ok: false, error: "DB error: " + (e?.message || "unknown") }, 500);
      }
    }

    // Admin update
    if (url.pathname.startsWith("/api/products/") && request.method === "PUT") {
      try {
        requireEnv();
        if (!(await requireAuth(request))) {
          return json({ ok: false, error: "Unauthorized" }, 401);
        }

        const id = decodeURIComponent(url.pathname.split("/").pop() || "");
        if (!id) return json({ ok: false, error: "Missing id" }, 400);

        const body = await request.json().catch(() => ({}));

        const current = await env.DB.prepare(
          "SELECT * FROM products WHERE id = ?"
        )
          .bind(id)
          .first();

        if (!current) return json({ ok: false, error: "Not found" }, 404);

        const currentSizes = JSON.parse(current.sizes || "[]");

        const nextName = String(body.name !== undefined ? body.name : current.name).trim();
        const nextPrice = Math.round(Number(body.price !== undefined ? body.price : current.price));
        const nextSizes = JSON.stringify(
          Array.isArray(body.sizes) ? body.sizes : currentSizes
        );
        const nextImageUrl = String(body.imageUrl !== undefined ? body.imageUrl : current.imageUrl).trim();

        const nextDiscountEnabled =
          (body.discountEnabled !== undefined ? body.discountEnabled : current.discountEnabled) ? 1 : 0;

        const nextDiscountPercent = Math.round(
          Number(body.discountPercent !== undefined ? body.discountPercent : (current.discountPercent || 0))
        );

        const nextOutOfStock =
          (body.outOfStock !== undefined ? body.outOfStock : current.outOfStock) ? 1 : 0;

        await env.DB.prepare(
          `UPDATE products
           SET name=?, price=?, sizes=?, imageUrl=?, discountEnabled=?, discountPercent=?, outOfStock=?
           WHERE id=?`
        )
          .bind(
            nextName,
            nextPrice,
            nextSizes,
            nextImageUrl,
            nextDiscountEnabled,
            nextDiscountPercent,
            nextOutOfStock,
            id
          )
          .run();

        return json({ ok: true });
      } catch (e) {
        return json({ ok: false, error: "DB error: " + (e?.message || "unknown") }, 500);
      }
    }

    // Admin delete
    if (url.pathname.startsWith("/api/products/") && request.method === "DELETE") {
      try {
        requireEnv();
        if (!(await requireAuth(request))) {
          return json({ ok: false, error: "Unauthorized" }, 401);
        }

        const id = decodeURIComponent(url.pathname.split("/").pop() || "");
        if (!id) return json({ ok: false, error: "Missing id" }, 400);

        await env.DB.prepare("DELETE FROM products WHERE id=?").bind(id).run();
        return json({ ok: true });
      } catch (e) {
        return json({ ok: false, error: "DB error: " + (e?.message || "unknown") }, 500);
      }
    }

    // Fallback
    return json({ ok: false, error: "Not found" }, 404);
  },
};
